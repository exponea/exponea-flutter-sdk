---
title: Authorization
excerpt: Full authorization reference for the Flutter SDK
slug: flutter-sdk-authorization
categorySlug: integrations
parentDocSlug: flutter-sdk-setup
---

The SDK exchanges data with the Engagement APIs through authorized HTTP/HTTPS communication. The SDK supports two authorization modes: the default **token authorization** for public API access and the more secure **customer token authorization** for private API access. Developers can choose the appropriate authorization mode for the required level of security.

## Token Authorization

The default token authorization mode provides [public API access](https://documentation.bloomreach.com/engagement/reference/authentication#public-api-access) using an API key as a token. 

Token authorization is used for the following API endpoints by default:

* `POST /track/v2/projects/<projectToken>/customers` for tracking of customer data
* `POST /track/v2/projects/<projectToken>/customers/events` for tracking of event data
* `POST /track/v2/projects/<projectToken>/campaigns/clicks` for tracking campaign events
* `POST /data/v2/projects/<projectToken>/customers/attributes` for fetching customer attributes
* `POST /data/v2/projects/<projectToken>/consent/categories` for fetching consents
* `POST /webxp/s/<projectToken>/inappmessages?v=1` for fetching InApp messages
* `POST /webxp/projects/<projectToken>/appinbox/fetch` for fetching of AppInbox data
* `POST /webxp/projects/<projectToken>/appinbox/markasread` for marking of AppInbox message as read
* `POST /campaigns/send-self-check-notification?project_id=<projectToken>` for part of self-check push notification flow

Developers must set the token using the `authorizationToken` [configuration](https://documentation.bloomreach.com/engagement/docs/flutter-sdk-configuration) parameter when [initializing the SDK](https://documentation.bloomreach.com/engagement/docs/flutter-sdk-setup#initialize-the-sdk):

```dart
final _plugin = ExponeaPlugin();
...
final config = ExponeaConfiguration(
    ...
    authorizationToken: "YOUR_API_KEY",
    ...
);
final configured = await _plugin.configure(config);
```

## Customer Token Authorization

Customer token authorization is optional and provides [private API access](https://documentation.bloomreach.com/engagement/docs/authentication#private-api-access) to select Engagement API endpoints. The [customer token](https://documentation.bloomreach.com/engagement/docs/customer-token) contains encoded customer IDs and a signature. When the Bloomreach Engagement API receives a customer token, it first verifies the signature and only processes the request if the signature is valid.

The customer token is encoded using **JSON Web Token (JWT)**, an open industry standard [RFC 7519](https://tools.ietf.org/html/rfc7519) that defines a compact and self-contained way for securely transmitting information between parties.

The SDK sends the customer token in `Bearer <value>` format. Currently, the SDK supports customer token authorization for the following Engagement API endpoints:

* `POST /webxp/projects/<projectToken>/appinbox/fetch` for fetching of AppInbox data
* `POST /webxp/projects/<projectToken>/appinbox/markasread` for marking of AppInbox message as read

Developers can enable customer token authorization by setting the `advancedAuthEnabled` [configuration](https://documentation.bloomreach.com/engagement/docs/ios-sdk-configuration) parameter to `true` when [initializing the SDK](https://documentation.bloomreach.com/engagement/docs/ios-sdk-setup#initialize-the-sdk):

```dart
final _plugin = ExponeaPlugin();
...
final config = ExponeaConfiguration(
    ...
    advancedAuthEnabled: true,
    ...
);
final configured = await _plugin.configure(config);
```

Additionally, developers must implement an authorization provider that provides a valid JWT token that encodes the relevant customer ID(s) and private API key ID. You must implement a different provider in native code for each platform.

> â—ï¸
>
> Customer tokens must be generated by a party that can securely verify the customer's identity. Usually, this means that customer tokens should be generated during the application backend login procedure. When the customer identity is verified (using password, 3rd party authentication, Single Sign-On, etc.), the application backend should generate the customer token and send it to the device running the SDK.

> ðŸ“˜
>
> Refer to [Generating customer token](https://documentation.bloomreach.com/engagement/docs/customer-token#generating-customer-token) in the customer token documentation for step-by-step instructions to generate a JWT customer token.


### Android Authorization Provider

First, implement the `com.exponea.sdk.services.AuthorizationProvider` interface as in the following example:

```kotlin
class ExampleAuthProvider : AuthorizationProvider {

    override fun getAuthorizationToken(): String? {
        return "eyJ0eXAiOiJKV1Q..."
    }
}
```

Then register your authorization provider in the `AndroidManifest.xml` file as in the following example:

```xml
<application
    ...
    <meta-data
        android:name="ExponeaAuthProvider"
        android:value="com.your.app.security.ExampleAuthProvider"
        />
</application>
```

#### Troubleshooting

If your authorization provider is not working correctly, SDK initialization will fail. Check the log for details:

1. If you enable customer token authorization using the configuration flag `advancedAuthEnabled` but the SDK can't find an AuthorizationProvider implementation, you'll see the following message logged:
   ```
   Advanced auth has been enabled but provider has not been found
   ```
2. If you register your class in `AndroidManifest.xml` but the SDK can't find that class, you'll see the following message logged:
   ```
   Registered <your class> class has not been found` with detailed info.
   ```
3. If you register your class in `AndroidManifest.xml` but the class doesn't implement the `AuthorizationProvider` interface, you'll see the following message logged:
   ```
   Registered <your class> class has to implement com.exponea.sdk.services.AuthorizationProvider
   ```

The AuthorizationProvider is loaded during SDK initialization or after calling `ExponeaPlugin().anonymize()`. You should see the above log messages at the same time.

### iOS Authorization Provider

Implement the `AuthorizationProviderType` protocol with the `@objc` attribute as in the following example:

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }
    public func getAuthorizationToken() -> String? {
        "YOUR JWT TOKEN"
    }
}
```

#### Troubleshooting

If you define `ExponeaAuthProvider` but it is not working as expected, check the logs for the following:

1. If you enable customer token authorization by setting the configuration flag `advancedAuthEnabled` to `true` but the SDK can't find a provider implementation, it will log the following message:
   ```
   Advanced authorization flag has been enabled without provider
   ```
2. The registered class musty extend `NSObject`. If it doesn't, you'll see the following log message:
   ```
   Class ExponeaAuthProvider does not conform to NSObject
   ```
2. The registered class must conform to `AuthorizationProviderType`. If it doesn't, you'll see the following log message:
   ```
   Class ExponeaAuthProvider does not conform to AuthorizationProviderType
   ```

### Asynchronous Authorization Provider Implementation

The customer token value is requested for every HTTP call at runtime. The method `getAuthorizationToken()` is written for synchronous usage but is invoked in a background thread. Therefore, you are able to block any asynchronous token retrieval (i.e. other HTTP call) and wait for the result by blocking this thread. If the token retrieval fails, you may return a NULL value but the request will automatically fail.

#### Example for Android:

```kotlin
class ExampleAuthProvider : AuthorizationProvider {
    override fun getAuthorizationToken(): String? = runBlocking {
        return@runBlocking suspendCoroutine { done ->
            retrieveTokenAsync(
                    success = {token -> done.resume(token)},
                    error = {error -> done.resume(null)}
            )
        }
    }
}
```

#### Example for iOS:

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }
    public func getAuthorizationToken() -> String? {
        let semaphore = DispatchSemaphore(value: 0)
        var token: String?
        let task = yourAuthTokenReqUrl.dataTask(with: request) {
            token = $0
            semaphore.signal()
        }
        task.resume()
        semaphore.wait()
        return token
    }
}
```

> 
>
> Different network libraries support different approaches but the principle stays same - feel free to block the invocation of the `getAutðŸ‘horizationToken` method.

### Customer Token Retrieval Policy

The customer token value is requested for every HTTP call that requires it.

Typically, JWT tokens have their own expiration lifetime and can be used multiple times. The SDK does not store the token in any cache. Developers may implement their own token cache as they see fit. For example:

Example for Android:

```kotlin
class ExampleAuthProvider : AuthorizationProvider {

    private var tokenCache: String? = null

    override fun getAuthorizationToken(): String? = runBlocking {
         if (tokenCache.isNullOrEmpty()) {
             tokenCache = suspendCoroutine { done ->
                 retrieveTokenAsync(
                     success = {token -> done.resume(token)},
                     error = {error -> done.resume(null)}
                 )
             }
         }
         return@runBlocking tokenCache
     }
}
```

Example for iOS:

```swift
@objc(ExponeaAuthProvider)
public class ExampleAuthProvider: NSObject, AuthorizationProviderType {
    required public override init() { }

    private var tokenCache: String?
    private var lifetime: Double?

    public func getAuthorizationToken() -> String? {
        if tokenCache == nil || hasExpired(lifetime) {
            (tokenCache, lifetime) = loadJwtToken()
        }
        return tokenCache
    }

    private func loadJwtToken() -> String? {
        ...
    }
}
```

> â—ï¸
>
> Please consider to store your cached token more securely. Android offers multiple options such as [KeyStore](https://developer.android.com/training/articles/keystore) or [Encrypted Shared Preferences](https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences).

> â—ï¸
>
> A customer token is valid until its expiration and is assigned to the current customer IDs. Bear in mind that if customer IDs change (due to invoking the `identifyCustomer` or `anonymize` methods), the customer token may become invalid for future HTTP requests invoked for new customer IDs.